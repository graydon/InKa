head	1.1;
access
	serge
	hutter
	inka;
symbols;
locks
	hutter:1.1; strict;
comment	@;;; @;


1.1
date	97.08.20.08.07.30;	author serge;	state Exp;
branches;
next	;


desc
@INKA normalisation (skolemization, prenex NF, etc.)
@


1.1
log
@Initial revision
@
text
@;;; -*- SYNTAX: COMMON-LISP;  PACKAGE: INKA -*-

(IN-PACKAGE :INKA)

(DEFVAR NORM*VARLIST NIL)


(DEFUN NORM-NORMALIZATION (EXPRESSION)
  
   ;;; Input  : \verb$EXPRESSION$ is a formula according to DA
   ;;; Effect : \verb$EXPRESSION$ is converted to an and-or form.
   ;;;          equivalence replacement is optimized with respect to cnf or dnf.
   ;;;          new objects are created for variables and skolem constants and functions.
   ;;; Value  : list of a clauselist which is a list of clauses which in turn is a list of literals. all clauses are variable disjoint.
   ;;; Remark : destructive on expression.

  (COND (EXPRESSION
         (SETQ EXPRESSION (NORM=REPLACE.EQV EXPRESSION NIL))
         (SETQ EXPRESSION (NORM=REPLACE.IMPL EXPRESSION))
         (SETQ EXPRESSION (NORM=MOVE.NEGATIONS.TO.LITERALS EXPRESSION))
         (SETQ EXPRESSION (NORM=SKOLEMIZE EXPRESSION NIL))
	 (SETQ EXPRESSION (NORM=FLATTEN.AND.OR EXPRESSION)))))


(DEFUN NORM-NORMALIZE.WITHOUT.QUANTIFIER (EXPRESSION)
  
  ;;; Edited : 15-jun-88
  ;;; Input  : an expression which may have variables which are not quantified
  ;;; Effect : destructively transforms \verb$EXPRESSION$ to clausal normal form
  ;;; Value  : list of clauses representing \verb$EXPRESSION$, format as in norm-normalization
  
  (COND (EXPRESSION
	 (SETQ EXPRESSION (NORM=REPLACE.EQV EXPRESSION NIL))
	 (SETQ EXPRESSION (NORM=REPLACE.IMPL EXPRESSION))
	 (SETQ EXPRESSION (NORM=MOVE.NEGATIONS.TO.LITERALS EXPRESSION))
	 (SETQ EXPRESSION (NORM=MOVE.QUANTIFIERS.OUTSIDE.AND.REMOVE.THEM EXPRESSION))
	 (SETQ EXPRESSION (NORM=FLATTEN.AND.OR EXPRESSION)))))


(DEFUN NORM-NORMALIZE.TO.DNF (EXPRESSION)
  ;;; Input:  an expression
  ;;; Value:  destructively transforms \verb$EXPRESSION$ to DNF

  (COND (EXPRESSION
	 (SETQ EXPRESSION (NORM=REPLACE.EQV EXPRESSION NIL))
	 (SETQ EXPRESSION (NORM=REPLACE.IMPL EXPRESSION))
	 (SETQ EXPRESSION (NORM=MOVE.NEGATIONS.TO.LITERALS EXPRESSION))
	 (SETQ EXPRESSION (NORM=TRANSFORM.TO.PSEUDO.DNF EXPRESSION))
	 (SETQ EXPRESSION (NORM=GET.DNFLIST EXPRESSION))
	 EXPRESSION)))


(DEFUN NORM-PRENEX.FORM (EXPRESSION)
  ;;; Edited: 31-jul-84 16:23:34 
  ;;; Input:  \verb$EXPRESSION$ as in norm-normalization
  ;;; Effect: destructively converts \verb$EXPRESSION$ to prenex form
  ;;; Value:  modified \verb$EXPRESSION$

  (SETQ EXPRESSION (NORM=REPLACE.EQV EXPRESSION NIL))
  (SETQ EXPRESSION (NORM=MOVE.QUANTIFIERS.OUTSIDE EXPRESSION))
  EXPRESSION)
 

(DEFUN NORM=REPLACE.EQV (EXPRESSION NEGATION.FLAG)
   ;;; EDITED : 27-JANUARY-1988 BY AM
   ;;; INPUT  : EXPRESSION
   ;;;          NEGATION.FLAG IS NIL IFF EXPRESSION LIES IN THE SCOPE OF AN EVEN NUMBER OF NEGATIONS
   ;;; EFFECT : DEPENDING ON NEGATION.FLAG EQV IS RESOLVED IN A WAY PROVIDING A RELATIVE  MINIMUM OF LITERALS
   ;;;          WHEN MULTIPLIED LATER TO CNF                                     
   ;;; VALUE  : EQUIVALENT EXPRESSION WITHOUT EQV          
  
  (COND ((DA-LITERAL.IS EXPRESSION) EXPRESSION)
	(T (CASE (DA-FORMULA.SYMBOL EXPRESSION)
	     (ALL (SETF (SECOND (DA-FORMULA.TERMLIST EXPRESSION))
			(NORM=REPLACE.EQV (SECOND (DA-FORMULA.TERMLIST EXPRESSION)) NEGATION.FLAG))
		  EXPRESSION)
	     (EX (SETF (SECOND (DA-FORMULA.TERMLIST EXPRESSION))
		       (NORM=REPLACE.EQV (SECOND (DA-FORMULA.TERMLIST EXPRESSION)) NEGATION.FLAG))
		 EXPRESSION)
	     (NOT (SETF (CAR (DA-FORMULA.TERMLIST EXPRESSION))
			(NORM=REPLACE.EQV (CAR (DA-FORMULA.TERMLIST EXPRESSION)) (NOT NEGATION.FLAG)))
		  EXPRESSION)
	     ((AND OR)
	      (SETF (DA-FORMULA.TERMLIST EXPRESSION)
		    (MAPCAR #'(LAMBDA (FORM) (NORM=REPLACE.EQV FORM NEGATION.FLAG)) (DA-FORMULA.TERMLIST EXPRESSION)))
	      EXPRESSION)
	     (IMPL (SETF (CAR (DA-FORMULA.TERMLIST EXPRESSION))
			 (NORM=REPLACE.EQV (CAR (DA-FORMULA.TERMLIST EXPRESSION)) (NOT NEGATION.FLAG)))
		   (SETF (SECOND (DA-FORMULA.TERMLIST EXPRESSION))
			 (NORM=REPLACE.EQV (SECOND (DA-FORMULA.TERMLIST EXPRESSION)) NEGATION.FLAG))
		   EXPRESSION)
	     (EQV (LET ((+LEFT (NORM=REPLACE.EQV (NORM=COPY (CAR (DA-FORMULA.TERMLIST EXPRESSION)))
						 NEGATION.FLAG)) 
			(-LEFT (NORM=REPLACE.EQV (DA-formula.negate (CAR (DA-FORMULA.TERMLIST EXPRESSION)))
						 NEGATION.FLAG)) 
			(+RIGHT (NORM=REPLACE.EQV (NORM=COPY (SECOND (DA-FORMULA.TERMLIST EXPRESSION)))
						  NEGATION.FLAG)) 
			(-RIGHT (NORM=REPLACE.EQV (DA-FORMULA.NEGATE (SECOND (DA-FORMULA.TERMLIST EXPRESSION)))
						  NEGATION.FLAG)))
		     (COND (NEGATION.FLAG
			   (SETF (DA-FORMULA.SYMBOL EXPRESSION) 'OR)
			   (SETF (CAR (DA-FORMULA.TERMLIST EXPRESSION)) (DA-FORMULA.CREATE 'AND (LIST +LEFT +RIGHT)))
			   (SETF (SECOND (DA-FORMULA.TERMLIST EXPRESSION))
				 (DA-FORMULA.CREATE 'AND (LIST -LEFT -RIGHT))))
			  (T (NORM=MARK.EQV +LEFT)
			     (NORM=MARK.EQV -LEFT)
			     (NORM=MARK.EQV +RIGHT)
			     (NORM=MARK.EQV -RIGHT)
			   (SETF (DA-FORMULA.SYMBOL EXPRESSION) 'AND)
			   (SETF (CAR (DA-FORMULA.TERMLIST EXPRESSION)) (DA-FORMULA.CREATE 'OR (LIST +LEFT -RIGHT)))
			   (SETF (SECOND (DA-FORMULA.TERMLIST EXPRESSION))
				 (DA-FORMULA.CREATE 'OR (LIST -LEFT +RIGHT))))))
		  EXPRESSION)
	     (OTHERWISE (ERROR "ILLEGAL EXPRESSION IN NORM=REPLACE.EQV:" EXPRESSION))))))


(DEFUN NORM=MARK.EQV (EXPRESSION)

  ;;; Input:  the left or right-side of an equivalence.
  ;;; Effect: if formula is denotes a literal, the literal is marked as one side of an equivalence.
  ;;; Value:  undefined.
  
  (COND ((DA-LITERAL.IS EXPRESSION)
	 (SETF (GETF (DA-LITERAL.ATTRIBUTES EXPRESSION) 'EQV) T))
	(T (CASE (DA-FORMULA.SYMBOL EXPRESSION)
		 (NOT (NORM=MARK.EQV (CAR (DA-FORMULA.TERMLIST EXPRESSION))))))))


(DEFUN NORM=REPLACE.IMPL (EXPRESSION)
   ;;; EDITED : 27-JANUARY-1988 BY AM 
   ;;; INPUT  : EXPRESSION
   ;;; EFFECT : IN EXPRESSION IMPL IS REPLACED DESTRUCTIVELY BY NOT AND OR
   ;;; VALUE  : MODIFIED EXPRESSION

  (COND ((DA-LITERAL.IS EXPRESSION) EXPRESSION)
	(T (CASE (DA-FORMULA.SYMBOL EXPRESSION)
	     ((ALL EX) (SETF (SECOND (DA-FORMULA.TERMLIST EXPRESSION))
			     (NORM=REPLACE.IMPL (SECOND (DA-FORMULA.TERMLIST EXPRESSION)))) EXPRESSION)

	     (NOT (SETF (CAR (DA-FORMULA.TERMLIST EXPRESSION)) 
			(NORM=REPLACE.IMPL (CAR (DA-FORMULA.TERMLIST EXPRESSION)))) EXPRESSION)

	     ((AND OR IMPL EQV)
	      (SETF (DA-FORMULA.TERMLIST EXPRESSION)
		    (MAPCAR #'(LAMBDA (FORM) (NORM=REPLACE.IMPL FORM)) (DA-FORMULA.TERMLIST EXPRESSION)))
	      (COND ((EQUAL (DA-FORMULA.SYMBOL EXPRESSION) 'IMPL)
		     (SETF (DA-FORMULA.SYMBOL EXPRESSION) 'OR)
		     (SETF (CAR (DA-FORMULA.TERMLIST EXPRESSION))
			   (DA-FORMULA.NEGATE (CAR (DA-FORMULA.TERMLIST EXPRESSION)))))
		    (T NIL))
	      EXPRESSION)
	     (OTHERWISE (ERROR "ILLEGAL EXPRESSION IN NORM=REPLACE.IMPL: " EXPRESSION))))))



(DEFUN NORM=MOVE.NEGATIONS.TO.LITERALS (EXPRESSION)
  ;;; INPUT:  EXPRESSION NOT CONTAINING IMPL, EQV.
  ;;; VALUE:  EQUIVALENT EXPRESSION WITHOUT NOT, I.E. NEGATIONS ARE REFLECTED BY MINUS SIGNS IN
  ;;;         LITERALS ONLY.

  (COND ((DA-LITERAL.IS EXPRESSION) EXPRESSION)
	(T (CASE (DA-FORMULA.SYMBOL EXPRESSION)
	     ((ALL EX)
	      (SETF (SECOND (DA-FORMULA.TERMLIST EXPRESSION))
		    (NORM=MOVE.NEGATIONS.TO.LITERALS (SECOND (DA-FORMULA.TERMLIST EXPRESSION))))
	      EXPRESSION)
	     ((AND OR)
	      (SETF (DA-FORMULA.TERMLIST EXPRESSION)
		    (MAPCAR #'(LAMBDA (FORM)
				(NORM=MOVE.NEGATIONS.TO.LITERALS FORM))
			    (DA-FORMULA.TERMLIST EXPRESSION)))
	      EXPRESSION)
	     (NOT (SETQ EXPRESSION (CAR (DA-FORMULA.TERMLIST EXPRESSION)))
		  (COND ((DA-LITERAL.IS EXPRESSION)
			 (COND ((DA-SIGN.IS.POSITIVE (DA-LITERAL.SIGN EXPRESSION))
				(SETF (DA-LITERAL.SIGN EXPRESSION) '-))
			       (T (SETF (DA-LITERAL.SIGN EXPRESSION) '+)))
			 EXPRESSION)
			(T (CASE (DA-FORMULA.SYMBOL EXPRESSION)
			     (ALL (SETF (DA-FORMULA.SYMBOL EXPRESSION) 'EX)
				  (SETF (SECOND (DA-FORMULA.TERMLIST EXPRESSION))
					(NORM=MOVE.NEGATIONS.TO.LITERALS
					 (DA-FORMULA.NEGATE (SECOND (DA-FORMULA.TERMLIST EXPRESSION)))))
				  EXPRESSION)
			     (EX (SETF (DA-FORMULA.SYMBOL EXPRESSION) 'ALL)
				 (SETF (SECOND (DA-FORMULA.TERMLIST EXPRESSION))
				       (NORM=MOVE.NEGATIONS.TO.LITERALS
					(DA-FORMULA.NEGATE (SECOND (DA-FORMULA.TERMLIST EXPRESSION)))))
				 EXPRESSION)
			     (AND (SETF (DA-FORMULA.SYMBOL EXPRESSION) 'OR)
				  (SETF (DA-FORMULA.TERMLIST EXPRESSION)
					(MAPCAR #'(LAMBDA (FORM)
						    (NORM=MOVE.NEGATIONS.TO.LITERALS (DA-FORMULA.NEGATE FORM)))
						(DA-FORMULA.TERMLIST EXPRESSION)))
				  EXPRESSION)
			     (OR (SETF (DA-FORMULA.SYMBOL EXPRESSION) 'AND)
				 (SETF (DA-FORMULA.TERMLIST EXPRESSION)
					(MAPCAR #'(LAMBDA (FORM)
						    (NORM=MOVE.NEGATIONS.TO.LITERALS (DA-FORMULA.NEGATE FORM)))
						(DA-FORMULA.TERMLIST EXPRESSION)))
				 EXPRESSION)
			     (NOT (NORM=MOVE.NEGATIONS.TO.LITERALS (CAR (DA-FORMULA.TERMLIST EXPRESSION))))
			     (OTHERWISE (ERROR "ILLEGAL EXPRESSION IN NORM=MOVE.NEGATIONS.TO.LITERALS:"
					       EXPRESSION))))))
	     (OTHERWISE (ERROR "ILLEGAL EXPRESSION IN NORM=MOVE.NEGATIONS.TO.LITERALS:" EXPRESSION))))))



(DEFUN NORM=SKOLEMIZE (EXPRESSION ENVIRONMENT)
  ;;; EDITED : 27-JANUARY-1988 BY AM
  ;;; INPUT  : EXPRESSION NOT CONTAINING IMPL, EQV, NOT
  ;;;          ENVIRONMENT: LIST OF UNIVERSALLY QUANTIFIED VARIABLES IN WHOSE SCOPE EXPRESSION LIES
  ;;; EFFECT : THE CORRESPONDING VARIABLES ARE REPLACED BY SKOLEM TERMS
  ;;; VALUE  : EXPRESSION WITHOUT EXISTENTIAL QUANTIFIERS
  
  (COND ((DA-LITERAL.IS EXPRESSION) EXPRESSION)
	(T (CASE (DA-FORMULA.SYMBOL EXPRESSION)
	     ((AND OR)
	      (MAPL #'(LAMBDA (FORM)
			(SETF (CAR FORM) (NORM=SKOLEMIZE (CAR FORM) ENVIRONMENT)))
		    (DA-FORMULA.TERMLIST EXPRESSION))
	      EXPRESSION)
	     (ALL (NORM=SKOLEMIZE (SECOND (DA-FORMULA.TERMLIST EXPRESSION))
				  (CONS (CAR (DA-FORMULA.TERMLIST EXPRESSION)) ENVIRONMENT)))
	     (EX (LET ((EX.VARIABLE (CAR (DA-FORMULA.TERMLIST EXPRESSION))) SKOLEM.TERM
		       (RIGHT (NORM=SKOLEMIZE (SECOND (DA-FORMULA.TERMLIST EXPRESSION)) ENVIRONMENT)))
		   (SETQ SKOLEM.TERM (NORM=NEW.TERM ENVIRONMENT EX.VARIABLE))
		   (SETQ RIGHT (NORM=REPLACE.VARIABLE EX.VARIABLE SKOLEM.TERM RIGHT))
		   RIGHT))
	     (OTHERWISE (ERROR "ILLEGAL EXPRESSION IN NORM=SKOLEMIZE:" EXPRESSION))))))



(DEFUN NORM=MOVE.QUANTIFIERS.OUTSIDE.AND.REMOVE.THEM (EXPRESSION)
  
  (NORM=EXTRACT.PREFIX.MATRIX EXPRESSION NIL))

  
(DEFUN NORM=MOVE.QUANTIFIERS.OUTSIDE (EXPRESSION)
  ;;; EDITED:  5-AUG-84 14:37:49        NE
  ;;; INPUT:  EXPRESSION NOT CONTAINING EQV
  ;;; VALUE:  PRENEX FORM OF EXPRESSION

  (MULTIPLE-VALUE-BIND (FORMULA QUANTORS) (NORM=EXTRACT.PREFIX.MATRIX EXPRESSION NIL)
    (NORM=QUANTIFICATION.CLOSURE QUANTORS FORMULA)))


(DEFUN NORM=QUANTIFICATION.CLOSURE (QUANTORS FORMULA)

  (COND ((NULL QUANTORS) FORMULA)
	(T (DA-FORMULA.QUANTIFICATION.CLOSURE (CAAR QUANTORS) (LIST (CDAR QUANTORS))
					      (NORM=QUANTIFICATION.CLOSURE (CDR QUANTORS) FORMULA)))))



(DEFUN NORM=TRANSFORM.TO.PSEUDO.CNF (EXPRESSION)
  ;;; INPUT:  EXPRESSION NOT CONTAINING EQV, IMPL, NOT
  ;;; VALUE:  EQUIVALENT EXPRESSION IN PSEUDO CNF, I.E. QUANTIFIED SUBEXPRESSIONS ARE TREATED LIKE
  ;;;         LITERALS BUT THEIR SUBEXPRESSIONS IN TURN ARE ALSO TRANSFORMED TO CNF

  (COND ((DA-LITERAL.IS EXPRESSION) EXPRESSION)
	(T (CASE (DA-FORMULA.SYMBOL EXPRESSION)
	     ((ALL EX)
	      (SETF (SECOND (DA-FORMULA.TERMLIST EXPRESSION))
		    (NORM=TRANSFORM.TO.PSEUDO.CNF (SECOND (DA-FORMULA.TERMLIST EXPRESSION))))
	      EXPRESSION)
	     (AND (MAPL #'(LAMBDA (FORM)
			    (SETF (CAR FORM) (NORM=TRANSFORM.TO.PSEUDO.CNF (CAR FORM))))
			(DA-FORMULA.TERMLIST EXPRESSION))
		  EXPRESSION)
	     (OR (MAPL #'(LAMBDA (FORM)
			   (SETF (CAR FORM) (NORM=TRANSFORM.TO.PSEUDO.CNF (CAR FORM))))
		       (DA-FORMULA.TERMLIST EXPRESSION))
		 (NORM=MULTIPLY.TO.CNF EXPRESSION))
	     (OTHERWISE (ERROR "ILLEGAL EXPRESSION IN NORM=TRANSFORM.TO.PSEUDO.CNF:" EXPRESSION))))))


(DEFUN NORM=TRANSFORM.TO.PSEUDO.DNF (EXPRESSION)
  ;;; INPUT:  EXPRESSION NOT CONTAINING EQV, IMPL, NOT
  ;;; VALUE:  EQUIVALENT EXPRESSION IN PSEUDO DNF, I.E. QUANTIFIED SUBEXPRESSIONS ARE TREATED LIKE
  ;;;         LITERALS BUT THEIR SUBEXPRESSIONS IN TURN ARE ALSO TRANSFORMED TO DNF

  (COND ((DA-LITERAL.IS EXPRESSION) EXPRESSION)
	(T (CASE (DA-FORMULA.SYMBOL EXPRESSION)
	     ((ALL EX)
	      (SETF (SECOND (DA-FORMULA.TERMLIST EXPRESSION))
		    (NORM=TRANSFORM.TO.PSEUDO.DNF (SECOND (DA-FORMULA.TERMLIST EXPRESSION))))
	      EXPRESSION)
	     (OR (MAPL #'(LAMBDA (FORM)
			   (SETF (CAR FORM) (NORM=TRANSFORM.TO.PSEUDO.DNF (CAR FORM))))
		       (DA-FORMULA.TERMLIST EXPRESSION))
		 EXPRESSION)
	     (AND (MAPL #'(LAMBDA (FORM)
			    (SETF (CAR FORM) (NORM=TRANSFORM.TO.PSEUDO.DNF (CAR FORM))))
			(DA-FORMULA.TERMLIST EXPRESSION))
		  (NORM=MULTIPLY.TO.DNF EXPRESSION))
	     (OTHERWISE (ERROR "ILLEGAL EXPRESSION IN NORM=TRANSFORM.TO.PSEUDO.DNF:" EXPRESSION))))))



(DEFUN NORM=GET.CLAUSELIST (EXPRESSION)
  ;;; INPUT  : EXPRESSION IN PRENEX FORM
  ;;; EFFECT : TRANSFORMS EXPRESSION TO LIST OF CLAUSES
  ;;; VALUE  : LIST OF CLAUSES

  (LET ((PREFIX.MATRIX (DA-FORMULA.QUANTIFICATION.OPEN 'ALL EXPRESSION))
        FORMULA
        VARIABLES)
    (SETQ VARIABLES (CAR PREFIX.MATRIX))
    (SETQ FORMULA (CDR PREFIX.MATRIX))
    (NORM=FLATTEN.CLAUSELIST FORMULA VARIABLES)))


(DEFUN NORM=RENAME.VARIABLES.IN.TERMS (TERMLIST VARIABLE OCCURRENCE LITERAL)
;;; EDITED : 27-JANUARY-1988 BY AM
;;; INPUT  : TERMLIST   ...LIST OF ARGUMENTS OF A PREDICATE OR A FORMULA
;;;          VARIABLE   ...QUANTIFIED VARIABLE ACTUALLY OF INTEREST
;;;          OCCURRENCE ...LIST OF VARIABLES TO OCCUR IN ACTUAL SUBFORMULA 
;;; EFFECT : VARIABLES IN TERMLIST ARE COLLECTED IN OCCURRENCE
;;;          IF VARIABLE HAS BINDING 'CREATE, 'CREATE IS REPLACED BY A NEW DT-VARIABLE
;;; VALUE  : (EVENTUALLY) MODIFIED OCCURRENCE
  
  (LET (TERM VAR)
    (MAPL #'(LAMBDA (RESTTERMLIST)
	       (SETQ TERM (CAR RESTTERMLIST))
	       (COND ((DA-VARIABLE.IS (SETQ VAR (DA-TERM.SYMBOL TERM)))
		      (SETQ OCCURRENCE (ADJOIN VAR OCCURRENCE))
		      (COND ((AND VARIABLE (EQ VAR VARIABLE))
			     (COND ((DA-VARIABLE.BINDING VAR)
				    (COND ((DA-VARIABLE.IS (DA-VARIABLE.BINDING VAR))
					   (RPLACA RESTTERMLIST (DA-TERM.CREATE (DA-VARIABLE.BINDING VAR))))
					  (T 
					   (SETF (DA-VARIABLE.BINDING VAR)
						 (DA-VARIABLE.CREATE (DA-VARIABLE.SORT VAR)))
					   (RPLACA RESTTERMLIST (DA-TERM.CREATE (DA-VARIABLE.BINDING VAR))))))))))
		     (T
		      (SETQ OCCURRENCE
			    (NORM=RENAME.VARIABLES.IN.TERMS (DA-TERM.TERMLIST TERM) VARIABLE OCCURRENCE LITERAL)))))
          TERMLIST)
    OCCURRENCE))



(DEFUN NORM=RENAME.VARIABLES.IN.FORMULA (EXPRESSION VARIABLE OCCURRENCE)
  ;;; EDITED : 27-JANUARY-1988 BY AM
  ;;; INPUT  : SEE NORM=RENAME.VARIABLES.IN.TERMS
  ;;; EFFECT : 
  ;;; VALUE  : (EVENTUALLY) MODIFIED OCCURRENCE

  (COND ((DA-LITERAL.IS EXPRESSION)
	 (SETQ OCCURRENCE (NORM=RENAME.VARIABLES.IN.TERMS (DA-LITERAL.TERMLIST EXPRESSION)
							  VARIABLE OCCURRENCE EXPRESSION)))
	(T (CASE (DA-FORMULA.SYMBOL EXPRESSION)
	     ((AND OR)
	      (MAPC #'(LAMBDA (FORM)
			(SETQ OCCURRENCE (NORM=RENAME.VARIABLES.IN.FORMULA FORM VARIABLE OCCURRENCE)))
		    (DA-FORMULA.TERMLIST EXPRESSION))
	      OCCURRENCE)
	     ((ALL EX)
	      (SETQ OCCURRENCE (NORM=RENAME.VARIABLES.IN.FORMULA (SECOND (DA-FORMULA.TERMLIST EXPRESSION))
								 VARIABLE OCCURRENCE)))
	     (OTHERWISE (ERROR "ILLEGAL EXPRESSION IN NORM=RENAME.VARIABLES.IN.FORMULA:" EXPRESSION))))))



(DEFUN NORM=FLATTEN.AND.OR (EXPRESSION)

  ;;; Input:   a formula which contains only the junctors AND and OR
  ;;; Effect:  uses the associativity law of AND and OR to allow arbitray many arguments to these junctors
  ;;; Value:   the simplified formula.

  (let (symbol)
  (COND ((NOT (DA-LITERAL.IS EXPRESSION))
	 (SETQ SYMBOL (DA-GTERM.SYMBOL EXPRESSION))
	 (SETF (DA-GTERM.TERMLIST EXPRESSION)
	       (MAPCAN #'(LAMBDA (GTERM)
			     (SETQ GTERM (NORM=FLATTEN.AND.OR GTERM))
			     (COND ((EQ SYMBOL (DA-GTERM.SYMBOL GTERM))
				    (DA-GTERM.TERMLIST GTERM))
				   (T (LIST GTERM))))
		       (DA-GTERM.TERMLIST EXPRESSION)))
	 (COND ((AND (NULL (CDR (DA-GTERM.TERMLIST EXPRESSION)))
		     (DA-GTERM.TERMLIST EXPRESSION))
		(CAR (DA-GTERM.TERMLIST EXPRESSION)))
	       (T EXPRESSION)))
	(T EXPRESSION))))


(DEFUN NORM=CLAUSELIST (EXPRESSION)
  ;;; INPUT  : EXPRESSION IN PRENEX FORM
  ;;; EFFECT : TRANSFORM EXPRESSION TO CLAUSE LIST WITHOUT RENAMING OF VARIABLES
  ;;; VALUE  : MODIFIED EXPRESSION

  (LET ((PREFIX.MATRIX (DA-FORMULA.QUANTIFICATION.OPEN 'ALL EXPRESSION))
        FORMULA)
    (SETQ FORMULA (CDR PREFIX.MATRIX))
    (NORM=FLATTEN.C FORMULA)))



(DEFUN NORM=FLATTEN.C (EXPRESSION)
  ;;; INPUT  : SEE NORM=FLATTEN.CLAUSELIST
  ;;; EFFECT : AS NORM=FLATTEN.CLAUSELIST BUT VARIABLES ARE NOT RENAMED
  ;;; VALUE  : MODIFIED EXPRESSION

  (COND ((AND (DA-FORMULA.IS EXPRESSION) (EQ 'AND (DA-FORMULA.SYMBOL EXPRESSION)))
	 (MAPCAN #'(LAMBDA (FORM) (NORM=FLATTEN.C FORM)) (DA-FORMULA.TERMLIST EXPRESSION)))
	(T (LIST (NORM=FLATTEN.L EXPRESSION)))))


(DEFUN NORM=FLATTEN.L (EXPRESSION)
  ;;; INPUT  : SEE NORM.FLATTEN.LITLIST
  ;;; EFFECT : AS NORM.FLATTEN.LITLIST BUT VARIABLES ARE NOT RENAMED
  ;;; VALUE  : MODIFIED EXPRESSION

  (COND ((AND (DA-FORMULA.IS EXPRESSION) (EQ 'OR (DA-FORMULA.SYMBOL EXPRESSION)))
	 (MAPCAN #'(LAMBDA (FORM) (NORM=FLATTEN.L FORM)) (DA-FORMULA.TERMLIST EXPRESSION)))
	(T (LIST EXPRESSION))))


(DEFUN NORM=GET.DNFLIST (EXPRESSION)
  ;;; EFFECT : TRANSFORM EXPRESSION TO DNF LIST WITHOUT RENAMING OF VARIABLES
  ;;; VALUE  : MODIFIED EXPRESSION

  (LET ((PREFIX.MATRIX (DA-FORMULA.QUANTIFICATION.OPEN 'ALL EXPRESSION))
        FORMULA)
    (SETQ FORMULA (CDR PREFIX.MATRIX))
    (NORM=FLATTEN.DNF.C FORMULA)))



(DEFUN NORM=FLATTEN.DNF.C (EXPRESSION)
  ;;; INPUT  : SEE NORM=GET.DNFLIST
  ;;; EFFECT : AS NORM=FLATTEN.CLAUSELIST BUT VARIABLES ARE NOT RENAMED
  ;;; VALUE  : MODIFIED EXPRESSION

  (COND ((AND (DA-FORMULA.IS EXPRESSION) (EQ 'OR (DA-FORMULA.SYMBOL EXPRESSION)))
	 (MAPCAN #'(LAMBDA (FORM)  (NORM=FLATTEN.DNF.C FORM)) (DA-FORMULA.TERMLIST EXPRESSION)))
	(T (LIST (NORM=FLATTEN.DNF.L EXPRESSION)))))


(DEFUN NORM=FLATTEN.DNF.L (EXPRESSION)
  ;;; INPUT  : SEE NORM.FLATTEN.LITLIST
  ;;; EFFECT : AS NORM.FLATTEN.LITLIST BUT VARIABLES ARE NOT RENAMED
  ;;; VALUE  : MODIFIED EXPRESSION

  (COND ((AND (DA-FORMULA.IS EXPRESSION) (EQ 'AND (DA-FORMULA.SYMBOL EXPRESSION)))
	 (MAPCAN #'(LAMBDA (FORM) (NORM=FLATTEN.DNF.L FORM)) (DA-FORMULA.TERMLIST EXPRESSION)))
	(T (LIST EXPRESSION))))


(DEFUN NORM=FLATTEN.CLAUSELIST (EXPRESSION VARIABLES)
  ;;; INPUT  : EXPRESSION... FORMULA WITHOUT QUANTIFIERS; FORMULA CONTAINS ONLY AND, OR
  ;;;          VARIABLES...  LIST OF VARIABLES IN FORMULA
  ;;; EFFECT : TRANSFORMS FORMULA TO LIST OF CLAUSES
  ;;;          RENAMES VARIABLES WHERE NECESSARY
  ;;; VALUE  : LIST OF CLAUSES

  (LET (EXPRESSION1 EXPRESSION2 USED.VARIABLES)
    (COND ((AND (DA-FORMULA.IS EXPRESSION) (EQ 'AND (DA-FORMULA.SYMBOL EXPRESSION)))
	   (MULTIPLE-VALUE-SETQ (EXPRESSION1 VARIABLES) 
	     (NORM=FLATTEN.CLAUSELIST (CAR (DA-FORMULA.TERMLIST EXPRESSION)) VARIABLES))
           (MULTIPLE-VALUE-SETQ (EXPRESSION2 VARIABLES)
	     (NORM=FLATTEN.CLAUSELIST (SECOND (DA-FORMULA.TERMLIST EXPRESSION)) VARIABLES))
           (VALUES (NCONC EXPRESSION1 EXPRESSION2) VARIABLES))
	  (T (MULTIPLE-VALUE-SETQ (EXPRESSION1 USED.VARIABLES) 
	       (NORM=FLATTEN.LITLIST EXPRESSION VARIABLES NIL NIL))
	     (SETQ VARIABLES (NSET-DIFFERENCE VARIABLES USED.VARIABLES))
	     (VALUES (LIST EXPRESSION1) VARIABLES)))))



(DEFUN NORM=FLATTEN.LITLIST (EXPRESSION VARIABLES USED.VARIABLES VARLIST)
  ;;; INPUT  : EXPRESSION ONLY CONTAINING OR AND LITERALS, 
  ;;;          VARIABLES ... LIST OF VARIABLES IN WHOLE FORMULA
  ;;;          USED.VARIABLES... LIST OF VARIABLES FOUND IN EXPRESSION
  ;;;          VARLIST... ASSOCIATION LIST ((VARIABLE . NEW NAME OF VARIABLE)...)
  ;;; EFFECT : RENAMES VARIABLES WHERE NECESSARY, BUILDS A CLAUSE
  ;;; VALUE  : LIST OF MODIFIED EXPRESSION
  ;;;          MODIFIED USED.VARIABLES, VARLIST

  (LET (EXPRESSION1 EXPRESSION2)
    (COND ((DA-LITERAL.IS EXPRESSION)
	   (MULTIPLE-VALUE-SETQ (USED.VARIABLES VARLIST) (NORM=RENAME.VARIABLES.IN.TERMLIST  
							   (DA-LITERAL.TERMLIST EXPRESSION)
							   VARIABLES USED.VARIABLES VARLIST))
	   (COND ((DA-LITERAL.ATTRIBUTES EXPRESSION)
		  (SETF (DA-LITERAL.ATTRIBUTES EXPRESSION)
			(NSUBLIS VARLIST (DA-LITERAL.ATTRIBUTES EXPRESSION)))))
	   (VALUES (LIST EXPRESSION) USED.VARIABLES VARLIST))
	  ((EQ 'OR (DA-FORMULA.SYMBOL EXPRESSION))
	   (SETQ EXPRESSION2 (MAPCAN #'(LAMBDA (FORM)
					 (MULTIPLE-VALUE-SETQ (EXPRESSION1 USED.VARIABLES VARLIST)
					   (NORM=FLATTEN.LITLIST FORM VARIABLES USED.VARIABLES VARLIST)))
				     (DA-FORMULA.TERMLIST EXPRESSION)))
	   (VALUES EXPRESSION2 USED.VARIABLES VARLIST)))))




(DEFUN NORM=RENAME.VARIABLES.IN.TERMLIST (TERMLIST VARIABLES USED.VARIABLES VARLIST)
  ;;; INPUT  : TERMLIST ... LIST OF ARGUMENTS OF A LITERAL
  ;;;          REST => SEE NORM=FLATTEN.LITLIST
  ;;; EFFECT : MODIFIES USED.VARIABLES AND VARLIST WHERE NECESSARY
  ;;; VALUE  : MODIFIED USED.VARIABLES AND VARLIST

  (LET (TERM NEWVAR OLD.NEW VAR)
    (MAPL (FUNCTION (LAMBDA (RESTTERMLIST)
                      (SETQ TERM (CAR RESTTERMLIST))
                      (COND ((DA-VARIABLE.IS (SETQ VAR (DA-TERM.SYMBOL TERM)))
                             (COND ((MEMBER VAR VARIABLES)
				    (SETQ USED.VARIABLES (CONS VAR USED.VARIABLES)))
                                   (T (COND ((SETQ OLD.NEW (ASSOC VAR VARLIST))
                                             (RPLACA RESTTERMLIST (DA-TERM.CREATE (CDR OLD.NEW))))
                                            (T (SETQ NEWVAR (DA-VARIABLE.CREATE (DA-VARIABLE.SORT VAR) (DA-VARIABLE.PNAME VAR)))
                                               (RPLACA RESTTERMLIST (DA-TERM.CREATE NEWVAR))
                                               (SETQ VARLIST (ACONS VAR NEWVAR VARLIST)))))))
                            (T
                             (MULTIPLE-VALUE-SETQ (USED.VARIABLES VARLIST)
                                                  (NORM=RENAME.VARIABLES.IN.TERMLIST
                                                      (DA-TERM.TERMLIST TERM) VARIABLES USED.VARIABLES VARLIST))))))
          TERMLIST)
    (VALUES USED.VARIABLES VARLIST)))



(DEFUN NORM=EXTRACT.PREFIX.MATRIX (EXPRESSION INVERT.FLAG)
  ;;; EDITED: 3-FEBRUARY-1988 BY AM
  ;;; INPUT:  EXPRESSION NOT CONTAINING EQV; BOOLEAN
  ;;; EFFECT: COLLECTS THE QUANTIFIERS OF EXPRESSION IN THE PREFIX LEAVING THE QUANTIFIER FREE MATRIX
  ;;;         IF INVERT.FLAG IS NON-NIL, THE QUANTIFIERS IN THE PREFIX ARE INVERTED.
  ;;;         THE PREFIX HAS THE FORMAT OF AN EXPRESSION BUT WITH THE ATOM 'MATRIX AT THE POSITION
  ;;;         THE MATRIX HAS TO BE SUBSTITUTED IN IN ORDER TO OBTAIN THE PREFIX FORM OF EXPRESSION.
  ;;; VALUE:  DOTTED PAIR (MATRIX . PREFIX)
  
  (LET (QUANTORS FORM ALL.QUANTORS)
    (COND ((DA-LITERAL.IS EXPRESSION)
	   (VALUES EXPRESSION NIL))
	  (T (CASE (DA-FORMULA.SYMBOL EXPRESSION)
	       ((ALL EX)
		(MULTIPLE-VALUE-SETQ (FORM QUANTORS)
		  (NORM=EXTRACT.PREFIX.MATRIX (SECOND (DA-FORMULA.TERMLIST EXPRESSION)) INVERT.FLAG))
		(VALUES FORM
			(ACONS (COND (INVERT.FLAG
				      (CASE (DA-FORMULA.SYMBOL EXPRESSION)
					(ALL 'EX) (EX 'ALL)))
				     (T (DA-FORMULA.SYMBOL EXPRESSION)))
			       (CAR (DA-FORMULA.TERMLIST EXPRESSION))
			       QUANTORS)))
	       ((AND OR IMPL NOT)
		(MAPL #'(LAMBDA (TERMLIST)
			  (MULTIPLE-VALUE-SETQ (FORM QUANTORS)
			    (NORM=EXTRACT.PREFIX.MATRIX (CAR TERMLIST)
							(COND ((AND (MEMBER (DA-FORMULA.SYMBOL EXPRESSION) '(IMPL NOT))
								    (EQ TERMLIST (DA-FORMULA.TERMLIST EXPRESSION)))
							       (NOT INVERT.FLAG))
							      (T INVERT.FLAG))))
			  (SETF (CAR TERMLIST) FORM)
			  (SETQ ALL.QUANTORS (NCONC QUANTORS ALL.QUANTORS)))
		      (DA-FORMULA.TERMLIST EXPRESSION))
		(VALUES EXPRESSION ALL.QUANTORS))
	       (OTHERWISE (ERROR "ILLEGAL EXPRESSION IN NORM=EXTRACT.PREFIX.MATRIX: " EXPRESSION)))))))



(DEFUN NORM=MULTIPLY.TO.CNF (EXPRESSION)
  ;;; INPUT:  EXPRESSION HAS FORM (OR LEFT RIGHT)  ;;; FALSCH !!!!
  ;;; VALUE:  CNF OF EXPRESSION WHERE ANY SUBEXPRESSION WITH AN OPERATOR OTHER THAN AND,OR IS
  ;;;         TREATED AS IF IT WERE A LITERAL
  
  (LET ((LEFT (CAR (DA-FORMULA.TERMLIST EXPRESSION))) (RIGHT (SECOND (DA-FORMULA.TERMLIST EXPRESSION))))
    (COND ((AND (DA-FORMULA.IS LEFT) (EQ (DA-FORMULA.SYMBOL LEFT) 'AND))
       ;;  (OR (AND L.L L.R) R) ==> (AND (OR L.L R)(OR L.R R))
           (SETF (DA-FORMULA.SYMBOL EXPRESSION) 'AND)
           (SETF (CAR (DA-FORMULA.TERMLIST EXPRESSION))
                 (NORM=MULTIPLY.TO.CNF (DA-FORMULA.JUNCTION.CLOSURE 'OR (LIST (CAR (DA-FORMULA.TERMLIST LEFT)) RIGHT))))
           (SETF (SECOND (DA-FORMULA.TERMLIST EXPRESSION))
                 (NORM=MULTIPLY.TO.CNF (DA-FORMULA.JUNCTION.CLOSURE 'OR (LIST (SECOND (DA-FORMULA.TERMLIST LEFT)) (NORM=COPY RIGHT)))))
           EXPRESSION)
          ((AND (DA-FORMULA.IS RIGHT) (EQ (DA-FORMULA.SYMBOL RIGHT) 'AND))
       ;;  (OR L (AND R.L R.R)) ==> (AND (OR L R.L)(OR L R.R))
           (SETF (DA-FORMULA.SYMBOL EXPRESSION) 'AND)
           (SETF (CAR (DA-FORMULA.TERMLIST EXPRESSION))
                 (NORM=MULTIPLY.TO.CNF (DA-FORMULA.JUNCTION.CLOSURE 'OR (LIST LEFT (CAR (DA-FORMULA.TERMLIST RIGHT))))))
           (SETF (SECOND (DA-FORMULA.TERMLIST EXPRESSION))
                 (NORM=MULTIPLY.TO.CNF (DA-FORMULA.JUNCTION.CLOSURE 'OR (LIST (NORM=COPY LEFT) (SECOND (DA-FORMULA.TERMLIST RIGHT))))))
           EXPRESSION)
          (T EXPRESSION))))


(DEFUN NORM=MULTIPLY.TO.DNF (EXPRESSION)
  ;;; INPUT:  EXPRESSION HAS FORM (AND LEFT RIGHT) ;;; FALSCH !!!!
  ;;; VALUE:  DNF OF EXPRESSION WHERE ANY SUBEXPRESSION WITH AN OPERATOR OTHER THAN AND,OR IS
  ;;;         TREATED AS IF IT WERE A LITERAL
  
  (LET ((LEFT (CAR (DA-FORMULA.TERMLIST EXPRESSION))) (RIGHT (SECOND (DA-FORMULA.TERMLIST EXPRESSION))))
    (COND ((AND (DA-FORMULA.IS LEFT) (EQ (DA-FORMULA.SYMBOL LEFT) 'OR))
       ;;  (AND (OR L.L L.R) R) ==> (OR (AND L.L R)(AND L.R R))
           (SETF (DA-FORMULA.SYMBOL EXPRESSION) 'OR)
           (SETF (CAR (DA-FORMULA.TERMLIST EXPRESSION))
                 (NORM=MULTIPLY.TO.DNF (DA-FORMULA.JUNCTION.CLOSURE 'AND (LIST (CAR (DA-FORMULA.TERMLIST LEFT)) RIGHT))))
           (SETF (SECOND (DA-FORMULA.TERMLIST EXPRESSION))
                 (NORM=MULTIPLY.TO.DNF (DA-FORMULA.JUNCTION.CLOSURE 'AND (LIST (SECOND (DA-FORMULA.TERMLIST LEFT)) (NORM=COPY RIGHT)))))
           EXPRESSION)
          ((AND (DA-FORMULA.IS RIGHT) (EQ (DA-FORMULA.SYMBOL RIGHT) 'OR))
       ;;  (AND L (OR R.L R.R)) ==> (OR (AND L R.L)(AND L R.R))
           (SETF (DA-FORMULA.SYMBOL EXPRESSION) 'OR)
           (SETF (CAR (DA-FORMULA.TERMLIST EXPRESSION))
                 (NORM=MULTIPLY.TO.DNF (DA-FORMULA.JUNCTION.CLOSURE 'AND (LIST LEFT (CAR (DA-FORMULA.TERMLIST RIGHT))))))
           (SETF (SECOND (DA-FORMULA.TERMLIST EXPRESSION))
                 (NORM=MULTIPLY.TO.DNF (DA-FORMULA.JUNCTION.CLOSURE 'AND (LIST (NORM=COPY LEFT) (SECOND (DA-FORMULA.TERMLIST RIGHT))))))
	   EXPRESSION)
          (T EXPRESSION))))


(DEFUN NORM=COPY (EXPRESSION)
  ;;; EDITED : 3-FEBRUARY-1988 BY AM
  ;;; INPUT  : EXPRESSION
  ;;; VALUE  : COPY OF EXPRESSION

  (COND ((DA-LITERAL.IS EXPRESSION) (DA-LITERAL.COPY EXPRESSION))
	(T (CASE (DA-FORMULA.SYMBOL EXPRESSION)
	     ((ALL EX) (da-formula.create
			(DA-FORMULA.SYMBOL EXPRESSION)
			(list (CAR (DA-FORMULA.TERMLIST EXPRESSION))
			      (NORM=COPY (SECOND (DA-FORMULA.TERMLIST EXPRESSION))))))
	     (NOT (DA-FORMULA.NEGATE (NORM=COPY (CAR (DA-FORMULA.TERMLIST EXPRESSION)))))
	     ((AND OR IMPL EQV)
	      (DA-FORMULA.CREATE
		(DA-FORMULA.SYMBOL EXPRESSION)
		(MAPCAR #'(LAMBDA (FORM) (NORM=COPY FORM))
		        (DA-FORMULA.TERMLIST EXPRESSION))))
	     (OTHERWISE (ERROR "ILLEGAL EXPRESSION IN NORM=COPY:" EXPRESSION))))))



(DEFUN NORM=REPLACE.VARIABLE (VARIABLE TERM EXPRESSION)
   ;;; EDITED: 27-JANUARY-1988 BY AM
   ;;; INPUT:  EXPRESSION VARIABLE, TERM SELFEXPLAINING
   ;;; EFFECT: EACH OCCURRENCE OF VARIABLE IN ANY TERMLIST OF EXPRESSION IS DESTRUCTIVELY REPLACED BY
   ;;;         A COPY OF TERM
   ;;; VALUE:  MODIFIED EXPRESSION

  (COND ((DA-LITERAL.IS EXPRESSION)
	 (SETF (DA-LITERAL.TERMLIST EXPRESSION)
	       (NORM=REPLACE.VARIABLE.IN.TERMLIST VARIABLE TERM (DA-LITERAL.TERMLIST EXPRESSION)))
	 EXPRESSION)
	(T (CASE (DA-FORMULA.SYMBOL EXPRESSION)
	     ((ALL EX) (SETF (SECOND (DA-FORMULA.TERMLIST EXPRESSION))
			     (NORM=REPLACE.VARIABLE VARIABLE TERM (SECOND (DA-FORMULA.TERMLIST EXPRESSION))))
	      EXPRESSION)
	     (NOT (SETF (CAR (DA-FORMULA.TERMLIST EXPRESSION))
			(NORM=REPLACE.VARIABLE VARIABLE TERM (CAR (DA-FORMULA.TERMLIST EXPRESSION))))
		  EXPRESSION)
	     ((AND OR IMPL EQV)
	      (MAPL #'(LAMBDA (FORM)
			(SETF (CAR FORM) (NORM=REPLACE.VARIABLE VARIABLE TERM (CAR FORM))))
		    (DA-FORMULA.TERMLIST EXPRESSION))
	      EXPRESSION)		  
	     (OTHERWISE (ERROR "ILLEGAL EXPRESSION IN NORM=REPLACE.VARIABLE: " EXPRESSION))))))



(DEFUN NORM=REPLACE.VARIABLE.IN.TERMLIST (VARIABLE TERM TERMLIST)

   ;;; INPUT:  SELF EXPLAINING
   ;;; EFFECT: EACH OCCURRENCE OF VARIABLE IN TERMLIST IS DESTRUCTIVELY REPLACED BY A COPY OF TERM
   ;;; VALUE:  MODIFIED TERMLIST

  (MAPL (FUNCTION (LAMBDA (RESTTERMLIST)
                    (COND ((EQ VARIABLE (DA-TERM.SYMBOL (CAR RESTTERMLIST)))
                           (RPLACA RESTTERMLIST (DA-TERM.COPY TERM)))
                          (T (NORM=REPLACE.VARIABLE.IN.TERMLIST 
			       VARIABLE TERM (DA-TERM.TERMLIST (CAR RESTTERMLIST)))))))
        TERMLIST)
  TERMLIST)



(DEFUN NORM=NEW.TERM (DOMAIN.VARIABLES RANGE.VARIABLE)
  ;;; EDITED: 27-JANUARY-1988 BY AM
  ;;; INPUT:  A LIST OF VARIABLES AND A VARIABLE
  ;;; EFFECT: CREATES A NEW CONSTANT OR FUNCTION OBJECT
  ;;; VALUE:  NEW SKOLEM TERM OF THE RESPECTIVE DOMAIN AND RANGE
  
  (COND ((NULL DOMAIN.VARIABLES)
	 (DA-TERM.CREATE (DA-FUNCTION.CREATE (FORMAT NIL "_~A" RANGE.VARIABLE) (DA-VARIABLE.SORT RANGE.VARIABLE) NIL T)))
	(T (DA-TERM.CREATE (DA-FUNCTION.CREATE (FORMAT NIL "f_~A" RANGE.VARIABLE) (DA-VARIABLE.SORT RANGE.VARIABLE)
					       (MAPCAR #'DA-VARIABLE.SORT DOMAIN.VARIABLES)
					       T)
			   (MAPCAR #'(LAMBDA (X) (DA-TERM.CREATE X)) DOMAIN.VARIABLES)))))





(DEFUN NORM-GTERM.NEGATE (GTERM CONSTANTS)

  ;;; Input:   a gterm (but no term !) and a set of skolem constants
  ;;; Effect:  negates \verb$GTERM$ in the sense that:
  ;;;          \begin{itemize}
  ;;;          \item the junctors AND and OR are switched 
  ;;;          \item  all literals are negated
  ;;;          \item skolem-terms are changed to variables and variables are changed to skolem-terms
  ;;;          \end{itemize}
  ;;; Value:   a gterm iff \verb$GTERM$ can be negated, NIL else.

  (LET ((SUBST (NORM-GN.COMPUTE.REPLACEMENT GTERM CONSTANTS)))
       (COND ((EQ SUBST 'FAIL) 'FAIL)
	     (T (NORM=GN.SWITCH.AND.REPLACE GTERM SUBST)))))


(DEFUN NORM=GN.SWITCH.AND.REPLACE (GTERM REPLACEMENT)

  ;;; Input :  a gterm and an assoc-list
  ;;; Effect:  traverses gterms and create a new gterm with
  ;;;          - junctors AND and OR are switched
  ;;;          - all literals are negated and
  ;;;            - if FCT.VAR is menber of REPLACEMENT any term (FCT t1 ... tn) is replaced by VAR
  ;;;            - if VAR.TERM is member of REPLACEMENT any occurence of VAR is replaced by a copy of TERM.
  ;;; Value:  the new gterm

  (COND ((DA-LITERAL.IS GTERM)
	 (DA-LITERAL.CREATE (DA-SIGN.OTHER.SIGN (DA-LITERAL.SIGN GTERM))
			    (DA-LITERAL.SYMBOL GTERM)
			    (MAPCAR #'(LAMBDA (TERM) (NORM=GN.SWITCH.AND.REPLACE TERM REPLACEMENT))
				    (DA-LITERAL.TERMLIST GTERM))
			    (LIST 'PARENT GTERM)
			    (DA-LITERAL.COLOURS GTERM)))
	((DA-TERM.IS GTERM)
	 (LET (NEW.TERM)
	 (COND ((SETQ NEW.TERM (GETF REPLACEMENT (DA-TERM.SYMBOL GTERM)))
		(DA-TERM.COPY NEW.TERM))
	       (T (DA-TERM.CREATE (DA-TERM.SYMBOL GTERM)
				  (MAPCAR #'(LAMBDA (TERM) (NORM=GN.SWITCH.AND.REPLACE TERM REPLACEMENT))
					  (DA-TERM.TERMLIST GTERM))
				  (DA-TERM.COLOURS GTERM))))))
	(T (DA-GTERM.CREATE (CASE (DA-GTERM.SYMBOL GTERM)
				  (OR 'AND)
				  (AND 'OR))
			    (MAPCAR #'(LAMBDA (SUB.GTERM)
					      (NORM=GN.SWITCH.AND.REPLACE SUB.GTERM REPLACEMENT))
				    (DA-GTERM.TERMLIST GTERM))
			    (DA-GTERM.COLOURS GTERM)
			    (LIST 'PARENT GTERM)))))


(DEFUN NORM-GN.COMPUTE.REPLACEMENT (GTERM CONSTANTS)

  ;;; Input:   a gterm and a set of skolem constants
  ;;; Effect:  computes a replacement which replaces all skolem-terms (except \verb$CONSTANTS$)
  ;;;          by variables and all variables by new skolem-terms
  ;;; Value:   the computed substitution

  (CATCH 'NORM*SKOLEM.FAIL
   (MULTIPLE-VALUE-BIND (FCT.POS.ARGS VAR.POS SUBST) (NORM=GN.QUANTOR.POSITIONS GTERM CONSTANTS)
		       (SOMEF #'(LAMBDA (FCT POS.ARGS)
					(PUSH (CONS FCT (CDR POS.ARGS))
					      (GETF (DA-GTERM.ATTRIBUTES (DA-ACCESS (CAR POS.ARGS) GTERM)) 'FCTS))
					NIL)
			      FCT.POS.ARGS)
		       (SOMEF #'(LAMBDA (VAR POS)
					(PUSH VAR (GETF (DA-GTERM.ATTRIBUTES (DA-ACCESS POS GTERM)) 'VARS))
					NIL)
			      VAR.POS)
		       (NORM=GN.REPLACEMENT.CLOSURE (NORM=GN.SAMPLE.REPLACEMENT GTERM NIL NIL) SUBST))))


(DEFUN NORM=GN.SAMPLE.REPLACEMENT (GTERM NEW.VARS OLD.VARS)

  ;;; Input:   a gterm, two lists of variables and a replacement
  ;;; Effect:  walks throu GTERM and computes a correct sequence of all- and ex-quantors
  ;;;          of each node of GTERM such that the arguments of a skolem-function f is the
  ;;;          union of OLD.VARS and all all-quantified variables in front of f.
  ;;;          Next, a replacement is computed replacing variables by skolem-terms and
  ;;;          existing skolem-terms by variables.
  ;;; Value:   the computed replacement

  (LET (NEW.VAR REPLACEMENT)
       (SETQ REPLACEMENT (MAPCAN #'(LAMBDA (VAR)
					   (LIST VAR
						 (COND ((DA-VARIABLE.IS VAR)
							(PUSH VAR OLD.VARS)
							(NORM=NEW.TERM NEW.VARS VAR))
						       (T (SETQ NEW.VAR (DA-VARIABLE.CREATE (DA-FUNCTION.SORT VAR)))
							  (PUSH NEW.VAR NEW.VARS)
							  (DA-TERM.CREATE NEW.VAR)))))
				 (NORM=GN.ORDER.SYMBOL.SEQUENCES (GETF (DA-GTERM.ATTRIBUTES GTERM) 'VARS)
								 (GETF (DA-GTERM.ATTRIBUTES GTERM) 'FCTS)
								 OLD.VARS)))
				
       (COND ((NOT (DA-LITERAL.IS GTERM))
	      (NCONC (MAPCAN #'(LAMBDA (SUB.GTERM)
				       (NORM=GN.SAMPLE.REPLACEMENT SUB.GTERM NEW.VARS OLD.VARS))
			     (DA-GTERM.TERMLIST GTERM))
		     REPLACEMENT))
	     (T REPLACEMENT))))


(DEFUN NORM=GN.ORDER.SYMBOL.SEQUENCES (VARS FCTS VARIABLES)
  
  ;;; Input:  a list of variables, a list of dotted pairs fct.vars, and a list of variables
  ;;; Effect: computes a sequence of all symbols of VARS and FCTS such that
  ;;;         each skolem function fct occurs at a position in the sequence such that its arguments
  ;;;         (denoted by (CDR FCT.VARS)) is the union of VARIABLES and all variables occuring in front of fct.
  ;;; Value:  the computed sequence
  
  (LET (REMAINING.VARS ALL.SYMBOLS)
       (SETQ FCTS (SORT FCTS #'< :KEY #'LENGTH))
       (SETQ ALL.SYMBOLS (MAPCAN #'(LAMBDA (FCT.VARS)
					   (COND ((SUBSETP VARIABLES (CDR FCT.VARS))
						  (SETQ REMAINING.VARS (SET-DIFFERENCE (CDR FCT.VARS) VARIABLES))
						  (COND ((SUBSETP REMAINING.VARS VARS)
							 (SETQ VARS (SET-DIFFERENCE VARS REMAINING.VARS))
							 (SETQ VARIABLES (APPEND REMAINING.VARS VARIABLES))
							 (NCONC1 REMAINING.VARS (CAR FCT.VARS)))
							(T (THROW 'NORM*SKOLEM.FAIL 'FAIL))))
						 (T (THROW 'NORM*SKOLEM.FAIL 'FAIL))))
				 FCTS))
       (NCONC ALL.SYMBOLS VARS)))


(DEFUN NORM=GN.REPLACEMENT.CLOSURE (REPLACEMENT SUBST)

  ;;; Input:   a list of dotted pairs fct/var.term and a subtsitution
  ;;; Effect:  for each variable x of DOM(SUBST) with SUBST(x) = y and y.term is member of REPLACEMENT
  ;;;          a new dotted pair x.term is inserted in REPLACEMENT
  ;;; Value:   the extended replacement

  (UNI-SUBST.WITH.VARS (CAR SUBST)
		       #'(LAMBDA (VAR TERM IGNORE)
			   (DECLARE (IGNORE IGNORE))
			   (PUSH (CONS VAR (CASSOC (DA-TERM.SYMBOL TERM) REPLACEMENT)) REPLACEMENT)))
  REPLACEMENT)


(DEFUN NORM=GN.QUANTOR.POSITIONS (GTERM CONSTANTS)

  ;;; Input :  a gterm and a list of skolem constants
  ;;; Effect:  computes a set of positions for all- and ex- quantifiers in gterm, such that the g-term
  ;;:          obtained by - replacing skolem terms by ex-quantified variables and inserting the quantors
  ;;;          in the denoted positions - has GTERM as a result of skolemization.
  ;;; Value:   the set of positions and a substitution denoting the identifications of variables.
  
  (LET (TAFS SUPER.TAF RENAMING.POSSIBLE TERM FCT.POSITIONS (SUBSTS (LIST NIL)) FIRST.TERM)
       (COND ((EVERY #'(LAMBDA (FCT)
			       (SETQ FIRST.TERM NIL)
			       (SETQ TAFS (DA-SYMBOL.OCCURS.IN.GTERM.LITS FCT GTERM))
			       (SETQ SUPER.TAF (DA-TAF.COMMON.TAF TAFS))
			       (SETQ RENAMING.POSSIBLE (EQ (DA-GTERM.SYMBOL (DA-ACCESS SUPER.TAF GTERM)) 'AND))
			       (COND ((EVERY #'(LAMBDA (TAF)
						       (SETQ TERM (UNI-SUBST.APPLY (CAR SUBSTS) (DA-ACCESS TAF GTERM)))
						       (COND ((NULL FIRST.TERM) (SETQ FIRST.TERM TERM)))
						       (AND (NORM=CHECK.SKOLEM.ARGS TERM)
							    (SETQ SUBSTS (NORM=EXPAND.SUBSTITUTION
									  SUBSTS TERM FIRST.TERM RENAMING.POSSIBLE))))
					     (DA-SYMBOL.OCCURS.IN.GTERM FCT GTERM))
				      (SETF (GETF FCT.POSITIONS FCT)
					    (CONS (DA-TAF.COMMON.TAF TAFS)
						  (MAPCAR #'(LAMBDA (X) (DA-TERM.SYMBOL X))
							  (DA-TERM.TERMLIST FIRST.TERM))))
				      T)))
		     (DELETE-IF-NOT #'(LAMBDA (X)
					      (AND (DA-FUNCTION.SKOLEM X)
						   (NOT (MEMBER X CONSTANTS))))
				    (DA-GTERM.FUNCTIONS GTERM)))
	      (MULTIPLE-VALUE-BIND (X Y)
				   (NORM=GN.QUANTORS.MOVE.OUTSIDE FCT.POSITIONS (NORM=GN.ALL.QUANTORS.PLACE SUBSTS GTERM))
				   (VALUES X Y SUBSTS))))))


(DEFUN NORM=GN.QUANTORS.MOVE.OUTSIDE (FCT.POSITIONS VAR.POSITIONS)

  ;;; Input:   A property list with skolem-functions as indicators and dotted pairs taf.args as values
  ;;;          and a property list with variables as indicators and term-access-fcts as values
  ;;;          (taf denotes the position of the all/ex-quantor of the corresponding variable/skolem-fct)
  ;;; Effect:  if there is a skolem-fct which denoting ex-quantor is inside the scope of a variable
  ;;;          which is not member of the skolem-term, the ex-quantor and its arguments (iff they are also
  ;;;          in the scope of that variable) are moved to the node of that variable.
  ;;; Value:   the recalculated property-lists.

  (LET (VAR.POS)
       (COND ((SOMEF #'(LAMBDA (FCT POS.ARGS)
			       (DECLARE (IGNORE FCT))
			       (SOMEF #'(LAMBDA (VAR POS)
						(COND ((AND (NOT (MEMBER VAR (CDR POS.ARGS)))
							    (NOT (EQUAL POS (CAR POS.ARGS)))
							    (DA-TAF.IS.SUBTAF POS (CAR POS.ARGS)))
						  (SETF (CAR POS.ARGS) (COPY-TREE POS))
						  (MAPC #'(LAMBDA (VAR1)
								  (SETQ VAR.POS (GETF VAR.POSITIONS VAR1))
								  (COND ((AND  (NOT (EQUAL POS VAR.POS))
									       (DA-TAF.IS.SUBTAF POS VAR.POS))
									 (SETF (GETF VAR.POSITIONS VAR1) (COPY-TREE POS)))))
							(CDR POS.ARGS)))))
				      VAR.POSITIONS))
		     FCT.POSITIONS)
	      (NORM=GN.QUANTORS.MOVE.OUTSIDE FCT.POSITIONS VAR.POSITIONS))
	     (T (VALUES FCT.POSITIONS VAR.POSITIONS)))))


(DEFUN NORM=GN.ALL.QUANTORS.PLACE (SUBSTS GTERM)

  ;;; Input:   A list of one substitution and a gterm
  ;;; Effect:  computes for each variable the minimal subtree of GTERM such that all occurrences of that
  ;;;          variable in GTERM are inside that subtree (the position of its all-quantifier). If SUBSTS
  ;;;          identify two variables a common subtree for both variables is computed if their corresponding
  ;;;          subtrees are disjoint and conjunctively connected.
  ;;; Value:   a property-list denoting the positions of the all-quantors.
  
  (LET (VAR.POSITIONS TAF1 TAF2 SUPER.TAF)
       (MAPC #'(LAMBDA (VAR)
		       (SETF (GETF VAR.POSITIONS VAR)
			     (DA-TAF.COMMON.TAF (DA-SYMBOL.OCCURS.IN.GTERM.LITS VAR GTERM))))
	     (DA-GTERM.VARIABLES GTERM))
       (UNI-SUBST.WITH.VARS (CAR SUBSTS)
			    #'(LAMBDA (VAR TERM IGNORE)
				(DECLARE (IGNORE IGNORE))
				(SETQ TAF1 (GETF VAR.POSITIONS VAR))
				(SETQ TAF2 (GETF VAR.POSITIONS (DA-TERM.SYMBOL TERM)))
				(SETQ SUPER.TAF (DA-TAF.COMMON.TAF (LIST TAF1 TAF2)))
				(COND ((AND (NEQ (DA-GTERM.SYMBOL (DA-ACCESS SUPER.TAF GTERM)) 'OR)
					    (NOT (DA-TAF.IS.SUBTAF TAF1 TAF2))
					    (NOT (DA-TAF.IS.SUBTAF TAF2 TAF1)))
				       (SETF (GETF VAR.POSITIONS (DA-TERM.SYMBOL TERM)) SUPER.TAF)
				       (REMF VAR.POSITIONS VAR))
				      (T (THROW 'NORM*SKOLEM.FAIL 'FAIL)))))
       VAR.POSITIONS))


(DEFUN NORM=CHECK.SKOLEM.ARGS (SKOLEM.TERM)

  ;;; Input:  a term
  ;;; Value:  T iff all arguments of SKOLEM.TERM are pairwise distinct variables.
  
  (AND (EVERY #'(LAMBDA (ARG)
			(DA-VARIABLE.IS (DA-TERM.SYMBOL ARG)))
	      (DA-TERM.TERMLIST SKOLEM.TERM))
       (EQL (LENGTH (DA-TERM.TERMLIST SKOLEM.TERM))
	    (LENGTH (DA-GTERM.VARIABLES SKOLEM.TERM)))))


(DEFUN NORM=EXPAND.SUBSTITUTION (SUBSTS TERM1 TERM2 FLAG)

  ;;; Input:  a list of one substitution, two terms and a flag
  ;;; Value:  if FLAG is nil then if both TERMS are equal the original SUBSTS
  ;;;         else the merge of SUBSTS with the matcher of TERM1 and TERM2
  
  (COND ((NULL FLAG) (COND ((UNI-WITH.BINDINGS (CAR SUBSTS) (UNI-TERM.ARE.EQUAL TERM1 TERM2))
			    SUBSTS)))
	(T (LET (MATCHER)
		(UNI-WITH.BINDINGS (CAR SUBSTS)
				   (SETQ MATCHER (UNI-TERM.MATCH TERM1 TERM2)))
		(UNI-MATCHER.MERGE (CAR SUBSTS) (CAR MATCHER))))))



(DEFUN NORM-TRANSFORM.TO.NF (GTERM &OPTIONAL (TYPE 'DNF) )

  ;;; input  : a gterm as mclause and the type of the wished NF (DNF or CNF)
  ;;; value  : the gterm denoting \verb$GTERM$ in respective normal form

  (LET ((SYMBOL (COND ((EQ TYPE 'DNF) 'AND) (T 'OR)))
	NEW.FORMULA)
    (COND ((DA-LITERAL.IS GTERM) GTERM)
	  (T (SETQ NEW.FORMULA 
		   (DA-GTERM.CREATE (DA-GTERM.SYMBOL GTERM)
				    (MAPCAN #'(LAMBDA (SUBGTERM)
						(LET ((NEW.GT (NORM-TRANSFORM.TO.NF SUBGTERM TYPE)))
						  (COND ((EQ (DA-GTERM.SYMBOL GTERM) (DA-GTERM.SYMBOL NEW.GT))
							 (DA-GTERM.TERMLIST NEW.GT))
							(T (LIST NEW.GT)))))
					    (DA-GTERM.TERMLIST GTERM))))
	     (COND ((EQ SYMBOL (DA-GTERM.SYMBOL GTERM))
		    (NORM=TRANSFORM.JUNCTION.TO.NF NEW.FORMULA TYPE))
		   (T (NORM=FLATTEN.AND.OR NEW.FORMULA)))))))


	   
(DEFUN NORM=TRANSFORM.JUNCTION.TO.NF (GTERM TYPE)

  ;;; input  : a gterm denoting a formula as mclause (symbol t1...tn) : IF TYPE = DNF then symbol must be 'AND;
  ;;;          otherwise 'OR.
  ;;; effect : the gterm is transformed to one in the normal form denoted by TYPE
  ;;; value  : see effect

  (LET ((SYMBOL1 (COND ((EQ TYPE 'DNF) 'AND) (T 'OR)))
	(SYMBOL2 (COND ((EQ TYPE 'DNF) 'OR) (T 'AND)))
	ORLIST RESTLIST)
    (COND ((MULTIPLE-VALUE-SETQ (ORLIST RESTLIST) (NORM=EXTRACT.JUNCTIONS GTERM TYPE))
	      (NORM=FLATTEN.AND.OR
	       (DA-GTERM.CREATE SYMBOL2 (MAPCAR #'(LAMBDA (TL)
						  (NORM=TRANSFORM.JUNCTION.TO.NF (DA-GTERM.CREATE SYMBOL1 TL) TYPE))
					      (NORM=INJECT.JUNCTIONS.LIST ORLIST (LIST RESTLIST))))))
	     (T (NORM=FLATTEN.AND.OR GTERM)))))


(DEFUN NORM=EXTRACT.JUNCTIONS (GTERM TYPE)

  ;;; input  : a gterm denoting a formula as mclause (symbol t1...tn) : IF TYPE = DNF then symbol must be 'AND;
  ;;;          otherwise 'OR.
  ;;; value  : two lists, the first containing all those ti which are a disjunction (TYPE = DNF) or a conjunction (TYPE = CNF),
  ;;;          and the second containing the remaining ti

  (LET ((SYMBOL (COND ((EQ TYPE 'DNF) 'OR) (T 'AND)))
	ORLIST RESTLIST)
    (MAPC #'(LAMBDA (GT)
	      (COND ((EQ SYMBOL (DA-GTERM.SYMBOL GT)) (SETQ ORLIST (CONS GT ORLIST)))
		    (T (SETQ RESTLIST (CONS GT RESTLIST)))))
	  (DA-GTERM.TERMLIST GTERM))
    (VALUES ORLIST RESTLIST)))


(DEFUN NORM=INJECT.JUNCTIONS.LIST (ORLIST INTERMEDIATE.RESULT)

  ;;; effect : ORLIST is a list of gterms, each denoting a dis- or con-junction, INTERMEDIATE.RESULT is
  ;;;          a list of lists containing gterms which have to be con- or dis-junctively combined with
  ;;;          each member of ORLIST
  ;;; value  : the modified INTERMEDIATE.RESULT

  (COND ((NULL ORLIST) INTERMEDIATE.RESULT)
	(T (NORM=INJECT.JUNCTIONS.LIST (CDR ORLIST)
				       (MAPCAN #'(LAMBDA (GT)
							 (NORM=INJECT.SINGLE.JUNCTION GT INTERMEDIATE.RESULT))
					       (DA-GTERM.TERMLIST (CAR ORLIST)))))))


(DEFUN NORM=INJECT.SINGLE.JUNCTION (GTERM INTERMEDIATE.RESULT)

  ;;; input and effect : see NORM.INJECT.JUNCTIONS.LIST

  (MAPCAR #'(LAMBDA (GTERMLIST)
		    (CONS (DA-GTERM.COPY GTERM) (MAPCAR #'DA-GTERM.COPY GTERMLIST)))
	  INTERMEDIATE.RESULT))



(DEFMACRO NORM-TRANSFORM.TO.DNF (GTERM)

  ;;; input and effect see NORM-TRANSFORM.TO.NF

  `(NORM-TRANSFORM.TO.NF ,GTERM 'DNF))



(DEFMACRO NORM-TRANSFORM.TO.CNF (GTERM)

  ;;; input and effect see NORM-TRANSFORM.TO.NF

  `(NORM-TRANSFORM.TO.NF ,GTERM 'CNF))



(DEFUN NORM-NORMALIZE.GTERM (GTERM)

  ;;; Input:   a gterm
  ;;; Effect:  true and false literals are removed from nested positions and
  ;;;          AND, Or expressions are flattened if they are immeadetly nested.
  ;;; VAlue:   the computed gterm

  (COND ((DA-LITERAL.IS GTERM) GTERM)
	((EQ (DA-GTERM.SYMBOL GTERM) 'AND)
	 (norm=junction.closure 'AND
				(MAPCAN #'(LAMBDA (SUB.TERM)
					    (DELETE-IF #'(LAMBDA (X) (DA-FORMULA.IS.TRUE X))
						       (DA-FORMULA.JUNCTION.OPEN 'AND (NORM-NORMALIZE.GTERM SUB.TERM))))
					(DA-GTERM.TERMLIST GTERM))))
	 ((EQ (DA-GTERM.SYMBOL GTERM) 'OR)
	  (norm=junction.closure 'OR
				 (MAPCAN #'(LAMBDA (SUB.TERM)
					     (DELETE-IF #'(LAMBDA (X) (DA-FORMULA.IS.FALSE X))
							(DA-FORMULA.JUNCTION.OPEN 'OR (NORM-NORMALIZE.GTERM SUB.TERM))))
					 (DA-GTERM.TERMLIST GTERM))))))


(defun norm=junction.closure (junctor list.of.gterms)

  ;;; Input:   a junction (OR or AND) and a list of gterms
  ;;; Effect:  makes the closure of the gterms wrt the junctor and removes obvious
  ;;;          false (in case of OR) and true (in case of AND) formulas.
  ;;; Value:   the computed formula
  
  (cond ((eq junctor 'and) (cond ((member-if #'(lambda (x) (da-formula.is.false x)) list.of.gterms)
				  (da-literal.false))
				 (t (da-formula.junction.closure 'and list.of.gterms))))
	((eq junctor 'or) (cond ((member-if #'(lambda (x) (da-formula.is.true x)) list.of.gterms)
				 (da-literal.true))
				(t (da-formula.junction.closure 'or list.of.gterms))))))@
